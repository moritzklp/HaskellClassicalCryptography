
\section{Conclusion}\label{sec:Conclusion}

Our project successfully implemented encryption, decryption, and key generation capabilities for three classical ciphers: 
Caesar, Vigen√®re, and One-Time Pad. 
The Haskell implementation includes automated attacks for each cipher, enabling users to recover plaintext from ciphertexts through methods such as 
brute force attacks, frequency analysis, Kasiski examination, Friedman tests, and the Many-Time Pad attack.

The comprehensive user interface provides access to all implemented cryptographic operations and attack methods. 
Throughout this project, we observed a good alignment between Haskell's functional programming paradigm and the implementation of classical ciphers. 
The fact that classical ciphers are simply operations that transform inputs to outputs without maintaining state, 
pairs elegantly with Haskell's functional approach. 
Each cipher could be modeled as a series of pure functions, making the code both easy to understand 
and closely resembling the mathematical descriptions of the cryptographic algorithms.

\subsection{Future Work}
Our program has several opportunities for improvement. 
A priority would be implementing more sophisticated word prediction algorithms to complete partially recovered plaintexts, 
particularly when using the Many-Time Pad attack. This would increase the effectiveness of our cryptanalysis tools.

It would also be interesting to compare the performance of the Haskell implementations of the
ciphers to other programming languages like C or Java. Cryptographic operations often need to
be performed quickly in resource constrained systems so it would be interesting to see how well
Haskell performs in such scenarios.

The work by Liu and Wang on agent-based cryptographic systems \cite{liuWang2013:agentTypesHLPE} offers additional directions 
for future development that could build upon our current implementation.
